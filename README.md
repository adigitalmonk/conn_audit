# ConnAudit

This application provides a simple implementation for login brute force protection.

The two components for this are the Verification Plug macro and the Auditing API.
You can check out the sections below for more information on each component.

This application isn't meant to be a replacement for a _real_ solution and you'd assuredly be better suited using something production ready.

I wrote this originally for a small personal project that doesn't have a database or user records to track.
I decided to rewrite it into it's own module as a way to get better at Elixir by building a `DynamicSupervisor` and macro.

The way the system works is to place a Plug built using the `ConnAudit` macro in front of your login page.
The macro accepts a handler for what to do if the "verification" fails, otherwise it will just pass the `Plug.Conn` through to the next plug.

The module `ConnAudit` also exposes three functions:

- `fail/1`
- `succeed/1`
- `check/1`

For more information, check out the below README sections and the docs.

## Installation

** TODO: Write this better **

You can install this by adding it via Git.

```elixir
def deps do
  [
    {:conn_audit, github: "adigitalmonk/conn_audit", branch: "master"}
  ]
end
```

## Configuration

There are two settings for the application.

| Option | Purpose |
| :----- | :-----: |
| `:ttl` | The amount of time to hold on to the login attempts for the particular IP address. |
| `:lockout` | The number of failures before an audit check fails. |

Example for your `config.exs`.

```elixir
config :conn_audit, Auditing,
  ttl: 300000,
  lockout: 5
```

## Usage

### Verification Plug

The verification plug macro will create a plug `Plug` for you that will check the result of an audit.

If the audit passes, it will forward the `conn` on.  If it fails, it will pass the `conn` into the function that's passed in.

```elixir
defmodule AuditTest.Plug.Verify do
  use ConnAudit, on_reject: &handler/1
  import Phoenix.Controller, only: [redirect: 2]

  def handler(conn) do
    conn
    |> redirect(to: "/403")
    |> halt()
  end
end
```

When you `use ConnAudit`, there are two options that can be passed in.  

The first option, `:on_reject`, is the function that is used to handle the `conn` when an audit false.

The (optional) second option, `:resolver`, is used to convert a `conn` into a uniquely identifiable string for auditing purposes.
By default, this resolution is performed by taking the `host_ip` from the connection and converting it into a string.
E.g., `{127, 0, 0, 1}` -> `"127.0.0.1"`
If you choose to override this, you can do whatever you want but the token returned by the resolver **must** be a `binary`.

Then just add this `Plug` into your pipeline or attach it whatever routes you want auditing on.
Since this `Plug` will create a new GenServer for every new token generated by the resolver, I'd recommend limiting the number of routes you apply this to.

```elixir
  pipeline :audited do
    plug AuditTest.Plug.Verify
  end

  scope "/login", AuditTestingWeb do
    pipe_through [:browser, :audited]
    get "/", LoginController, :index
  end
```

You'd be better off relying on sessions to isolate the majority of your pages and having this `Plug` only on your actual login page.  That said, it can be used for any kind of auditing purposes to block access to specific pages, nothing says it has to be used for login controls.

### Auditing API

There are three functions as part of the auditing API.

**TODO - Define three functions**
**TODO - How the tokens work + resolution** 

```elixir
defmodule AuditTestWeb.LoginController do
  
  # Plug only on this page instead of in pipeline
  plug AuditTest.Plug.Verify

  def create(conn, %{
        "login_form" => %{
          "username" => username,
          "password" => password
        }
      }) do
    if Accounts.login(username, password) do
      ConnAudit.succeed(conn)

      conn
      |> put_session(:authenticated, username)
      |> redirect(to: "/")
    else    
      ConnAudit.fail(conn)

      conn
      |> put_flash(:error, "Invalid username or password.")
      |> redirect(to: "/auth/login")
    end
  end
end
```

## Logging

There are four `:telemetry` events executed in this application.

| Event | Description | Atoms | 
| :---: | :---: | :---: |
| Audit Success | A successful audit was performed for a token | `[:conn_audit, :audit, :success]` |
| Audit Failure | An unsuccessful audit was performed for a token | `[:conn_audit, :audit, :failure]` |
| Audit Lockout | A audit was considered "locked out" | `[:conn_audit, :audit, :lockout]` |
| Audit Timeout | The configured `:ttl` has passed and an audit is no longer valid | `[:conn_audit, :audit, :timeout]` |

All of the events have the same parameters and metadata.

### Parameters

- `attempts` is the number of failed attempts that happened up to that point
- `token` is the resolved token for the connection / user

### Metadata

- `timestamp` a UTC DateTime

# TODO

- Improve this document
- Simplify `resolver` configuration for Auditing API
- Write moduledocs
- Remove telemetry placeholders intended for testing
- Add tests
- Remove `config.exs` from local testing
